//===----------------------------------------------------------------------===//
// Copyright Â© 2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
module pkl.impl.ghactions.PklCI

import "@gha/actions/Artifact.pkl"
import "@gha/Context.pkl"
import "@gha/Workflow.pkl"

import "actions/PublishUnitTestResult.pkl"
import "util.pkl"

/// The workflow that runs during pull requests.
///
/// The following fields are overwritten and therefore don't need to be set:
///
///   * [Workflow.On.pull_request]
///   * [Workflow.name]
///   * [Workflow.permissions]
///   * [Workflow.concurrency]
///
/// This turns into a workflow called "Pull Request".
prb: Workflow

/// The workflow to run for commits that land on the main branch.
///
/// The following fields are amended with additional settings:
///   * [Workflow.On.push]
///   * [Workflow.name]
///   * [Workflow.permissions]
///   * [Workflow.concurrency]
///
/// This turns into a workflow called "Build (main)".
main: Workflow

/// The workflow to run for commits that land on all branches except for `main` and `release/*`
///
/// The following fields are amended with additional settings:
///   * [Workflow.On.push]
///   * [Workflow.name]
///   * [Workflow.permissions]
///   * [Workflow.concurrency]
///
/// This turns into a workflow called "Build".
build: Workflow

/// The workflow that runs when tags are pushed.
///
/// The following fields are amended with additional settings:
///   * [Workflow.On.push]
///   * [Workflow.name]
///   * [Workflow.permissions]
///   * [Workflow.concurrency]
///
/// This turns into a workflow called "Release".
release: Workflow?

/// The workflow that runs when commits land on `release/x.x` branches.
///
/// The following fields are amended with additional settings:
///   * [Workflow.On.push]
///   * [Workflow.name]
///   * [Workflow.permissions]
///   * [Workflow.concurrency]
///
/// This turns into a workflow called "Build (release branch)".
releaseBranch: Workflow?

/// Test reports produced by [build] and [release].
///
/// Turns into steps that upload and processes test results.
testReports: TestReports

/// Whether to trigger a build of the Pkl docsite or not.
///
/// * `"none"` - does not trigger build after the [release] workflow (default).
/// * `"release"` - trigger build after the [release] or [releaseBranch] workflows only.
/// * `"both"` - trigger build for the [release], [releaseBranch], and [main] workflows.
/// `both` should only be used for projects where we publish documentation
/// for dev/snapshot builds.
///
/// The workflow must be granted the `PKL_CI` secret.
///
/// Does not do anything if the repo's owner is not `apple`.
triggerDocsBuild: "none" | "release" | "both" = "none"

/// Whether to trigger a build of pkl-package-docs or not.
///
/// * `"none"` -- does not trigger a build after the [release] workflow (default).
/// * `"release"` -- trigger a build after the [release] or [releaseBranch] workflows.
/// * `"main"` -- trigger a build after the [main] workflow.
///
/// The workflow must be granted the `PKL_CI` secret.
///
/// Does not do anything if the repo's owner is not `apple`.
triggerPackageDocsBuild: "none" | "main" | "release" = "none"

class TestReports {
  /// Paths, directories, and globs to junit test reports, to be processed by a GitHub Actions test reporter.
  junit: Listing<String>

  /// Paths, directories, and globs to HTML test reports, to be uploaded as an artifact.
  html: Listing<String>

  /// Job key patterns to exclude from test report publishing.
  excludeJobs: Listing<String | Regex>

  function includes(jobKey: String): Boolean =
    !excludeJobs.any((pattern) ->
      if (pattern is Regex)
        pattern.matchEntire(jobKey) != null
      else
        pattern == jobKey
    )
}

local effectiveBuildWorkflow = (build) {
  name = "Build"
  permissions = new {
    contents = "read"
  }
  concurrency = new {
    // only run once at a time per branch
    group = "\(Context.github.workflow)-\(Context.github.ref)"
    `cancel-in-progress` = false // TODO remove once correctly marked nullable in upstream pkl-gha
  }
  on {
    push {
      `branches-ignore` {
        "main"
        "release/*"
      }
      `tags-ignore` {
        "**"
      }
    }
  }
  jobs = super.jobs |> withPublishTestResults |> withUploadTestResultHtml
}

local effectiveReleaseBranchWorkflow = (build) {
  name = "Build (release branch)"
  permissions = new {
    contents = "read"
  }
  concurrency = new {
    // only run once at a time per release branch
    group = "\(Context.github.workflow)-\(Context.github.ref)"
    `cancel-in-progress` = true
  }
  on {
    push {
      branches {
        "release/*"
      }
      `tags-ignore` {
        "**"
      }
    }
  }
  jobs =
    super.jobs
      |> withPublishTestResults
      |> withUploadTestResultHtml
      |> withTriggerWorkflows("release")
}

local effectiveMainWorkflow = (main) {
  name = "Build (main)"
  permissions = new {
    contents = "read"
  }
  concurrency = new {
    // only run once at a time
    group = "\(Context.github.workflow)-\(Context.github.ref)"
    `cancel-in-progress` = false // TODO remove once correctly marked nullable in upstream pkl-gha
  }
  on {
    push {
      branches {
        "main"
      }
      `tags-ignore` {
        "**"
      }
    }
  }
  jobs =
    super.jobs
      |> withPublishTestResults
      |> withUploadTestResultHtml
      |> withTriggerWorkflows("main")
}

/// Can't use [withPublishTestResults] because PRs submitted from forks can't create check runs.
/// Instead, testReportWorkflow gets triggered when this workflow is completed, and downloads the artifacts
/// published here.
local effectivePrbWorkflow = (prb) {
  name = "Pull Request"
  permissions = new {
    contents = "read"
  }
  concurrency = new {
    // cancel running workflows for the same PR
    group = "\(Context.github.workflow)-\(Context.github.ref)"
    `cancel-in-progress` = true
  }
  on {
    pull_request {}
  }
  jobs = (super.jobs |> withUploadTestResultXml |> withUploadTestResultHtml) {
    ["upload-event-file"] {
      `runs-on` = "ubuntu-latest"
      steps {
        new Artifact.Upload {
          name = "Upload event file"
          `if` = "!cancelled()"
          with {
            name = TEST_RESULT_EVENT_FILE_ARTIFACT_NAME
            path = Context.github.eventPath
          }
        }
      }
    }
  }
}

local effectiveReleaseWorkflow = (release) {
  name = "Release"
  permissions = new {
    contents = "read"
  }
  concurrency = new {
    // only run once at a time per tag
    group = "\(Context.github.workflow)-\(Context.github.ref)"
    `cancel-in-progress` = false // TODO remove once correctly marked nullable in upstream pkl-gha
  }
  on {
    push {
      tags {
        "**"
      }
      `branches-ignore` {
        "**"
      }
    }
  }
  jobs =
    super.jobs
      |> withPublishTestResults
      |> withUploadTestResultHtml
      |> withTriggerWorkflows("release")
}

local testReportWorkflow: Workflow = new {
  name = "PR Test Reports"
  permissions = new {
    contents = "read"
  }

  on {
    workflow_run {
      workflows {
        effectivePrbWorkflow.name
      }
      types {
        "completed"
      }
    }
  }

  jobs {
    ["test-results"] {
      name = "Test Results"
      `runs-on` = "ubuntu-latest"
      `if` =
        "github.event.workflow_run.conclusion == 'success' || github.event.workflow_run.conclusion == 'failure'"
      permissions {
        checks = "write"
        actions = "read"
      }
      steps {
        new {
          name = "Download artifacts"
          uses = "dawidd6/action-download-artifact@v11"
          with {
            ["path"] = "artifacts"
            ["name"] = "test-results-.*"
            ["name_is_regex"] = true
            ["run_id"] = "${{ github.event.workflow_run.id }}"
          }
        }
        new PublishUnitTestResult.Action {
          name = "Publish test results"
          with {
            commit = "${{ github.event.workflow_run.head_sha }}"
            event_name = "${{ github.event.workflow_run.event }}"
            event_file = "artifacts/\(TEST_RESULT_EVENT_FILE_ARTIFACT_NAME)/event.json"
            file_patterns { "artifacts/**/*.xml" }
            comment_mode = "off"
          }
        }
      }
    }
  }
}

local const TEST_RESULT_HTML_ARTIFACT_NAME = "test-results-html"

local const TEST_RESULT_XML_ARTIFACT_NAME = "test-results-xml"

local const TEST_RESULT_EVENT_FILE_ARTIFACT_NAME = "test-results-event-file"

local withUploadTestResultXml: Mixin<Workflow.Jobs> = (it) -> (it) {
  when (!testReports.junit.isEmpty) {
    for (key, _ in it) {
      when (testReports.includes(key)) {
        [key] {
          steps {
            new Artifact.Upload {
              name = "Upload Test Result XML"
              `if` = "!cancelled()"
              with {
                name = "\(TEST_RESULT_XML_ARTIFACT_NAME)-\(key)"
                path = testReports.junit.join("\n")
              }
            }
          }
        }
      }
    }
  }
}

local withUploadTestResultHtml: Mixin<Workflow.Jobs> = (it) -> (it) {
  when (!testReports.html.isEmpty) {
    for (key, _ in it) {
      when (testReports.includes(key)) {
        [key] {
          steps {
            new Artifact.Upload {
              name = "Upload Test Result HTML"
              `if` = "!cancelled()"
              with {
                name = "\(TEST_RESULT_HTML_ARTIFACT_NAME)-\(key)"
                path = testReports.html.join("\n")
              }
            }
          }
        }
      }
    }
  }
}

local withPublishTestResultsForMatrixBuild: Mixin<Workflow.Jobs> = (it) -> (it) {
  for (key, _ in it) {
    when (testReports.includes(key)) {
      [key] {
        local self = this
        steps {
          // matrix build; upload test results as an artifact
          new Artifact.Upload {
            name = "Upload Test Result XML"
            `if` = "!cancelled()"
            with {
              name =
                "\(TEST_RESULT_XML_ARTIFACT_NAME)-\(key)-\(self.strategy.matrix.keys.join("-"))"
              path = testReports.junit.join("\n")
            }
          }
        }
      }
    }
  }
  ["publish-test-results"] {
    needs = it.keys.filter((key) -> testReports.includes(key)).toListing()
    `runs-on` = "ubuntu-latest"
    permissions {
      checks = "write"
    }
    steps {
      new Artifact.Download {
        with {
          pattern = "\(TEST_RESULT_XML_ARTIFACT_NAME)-*"
        }
      }
      new PublishUnitTestResult.Action {
        name = "Publish test results"
        `if` = "!cancelled()"
        with {
          file_patterns = testReports.junit
          comment_mode = "off"
        }
      }
    }
  }
}

local withPublishTestResults: Mixin<Workflow.Jobs> = (it) ->
  if (testReports.junit.isEmpty)
    it
  else
    // if there are matrix builds, we need to publish test results as an xml artifact, then publish as a separate job.
    if (it.any((_, job) -> job.strategy?.matrix != null))
      it |> withPublishTestResultsForMatrixBuild
    else
      (it) {
        for (key, job in it) {
          when (testReports.includes(key)) {
            [key] {
              permissions {
                checks = "write"
              }
              steps {
                new PublishUnitTestResult.Action {
                  name = "Publish test results"
                  // if we can't figure out the correct OS, just try to use the linux version.
                  os = util.determineOS(job) ?? "linux"
                  `if` = "!cancelled()"
                  with {
                    file_patterns = testReports.junit
                    comment_mode = "off"
                  }
                }
              }
            }
          }
        }
      }

local function withTriggerWorkflows(triggerType: String): Mixin<Workflow.Jobs> = (it) -> (it) {
  when (
    triggerType == triggerDocsBuild
      || triggerType == triggerPackageDocsBuild
      || triggerDocsBuild == "both"
  ) {
    ["trigger-downstream-builds"] {
      needs {
        ...it.keys
      }
      `runs-on` = "ubuntu-latest"
      `if` = "github.repository_owner == 'apple'"
      steps {
        new {
          name = "Create app token"
          id = "app-token"
          uses = "actions/create-github-app-token@v2"
          with {
            ["app-id"] = Context.secrets("PKL_CI_CLIENT_ID")
            ["private-key"] = Context.secrets("PKL_CI")
            ["owner"] = Context.github.repositoryOwner
          }
        }
        when (triggerType == triggerDocsBuild || triggerDocsBuild == "both") {
          new {
            name = "Trigger pkl-lang.org build"
            env {
              ["GH_TOKEN"] = "${{ steps.app-token.outputs.token }}"
            }
            run =
              #"""
              gh workflow run \
                --repo apple/pkl-lang.org \
                --ref main \
                --field source_run="\#(Context.github.serverUrl)/\#(Context.github.repository)/actions/runs/\#(Context.github.runId)" \
                main.yml
              """#
          }
        }
        when (triggerType == triggerPackageDocsBuild) {
          new {
            name = "Trigger pkl-package-docs build"
            env {
              ["GH_TOKEN"] = "${{ steps.app-token.outputs.token }}"
            }
            run =
              #"""
              gh workflow run \
                --repo apple/pkl-package-docs \
                --ref main \
                --field source_run="\#(Context.github.serverUrl)/\#(Context.github.repository)/actions/runs/\#(Context.github.runId)" \
                main.yml
              """#
          }
        }
      }
    }
  }
}

output {
  files {
    ["workflows/prb.yml"] = effectivePrbWorkflow.output
    ["workflows/main.yml"] = effectiveMainWorkflow.output
    ["workflows/build.yml"] = effectiveBuildWorkflow.output
    when (release != null) {
      ["workflows/release.yml"] = effectiveReleaseWorkflow.output
    }
    when (releaseBranch != null) {
      ["workflows/release-branch.yml"] = effectiveReleaseBranchWorkflow.output
    }
    when (!testReports.junit.isEmpty) {
      ["workflows/test_report.yml"] = testReportWorkflow.output
    }
  } {
    // TODO remove when pkl-gha supports Job.container
    [[true]] {
      renderer {
        converters {
          [Workflow.DefaultJob] = (it) ->
            if (it.name?.startsWith("hawkeye-check:") ?? false)
              it
                .toMap()
                .put("container", Map("image", it.name.splitLimit(":", 2).last))
                .put("name", "hawkeye-check")
            else
              it
        }
      }
    }
  }
}
