//===----------------------------------------------------------------------===//
// Copyright Â© 2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
/// Generates the "lockfile" based off the defined workflows, as well as the exsiting lockfile (if
/// exists).
///
/// If an action does not already exist in the lockfile, fetches the git sha from GitHub.
/// Otherwise, uses the git sha as currently defined.
module pkl.impl.ghactions.LockfileGenerator

import "pkl:yaml"

import "@com.github.actions/Workflow.pkl"
import "@deepToTyped/deepToTyped.pkl"

workflows: List<Workflow>

const lockfileName = "workflows/__lockfile__.yml"

/// The current lock, if exists.
const currentLocks: Locks? =
  if (lockfileResource == null)
    null
  else
    let (mapping = yamlParser.parse(lockfileResource) as Mapping)
    let (workflow = deepToTyped.apply(Workflow.getClass(), mapping) as Workflow)
    let (locksJob = workflow.jobs.toMap().values.first)
      locksJob.steps
        .toList()
        .toMap(
          (it) -> it.name!!,
          (it) -> new LockEntry {
            base = it.uses.split("@")[0]
            version = it.name.split("@")[1]
            sha = it.uses.split("@")[1]
          },
        )

local const yamlParser: yaml.Parser = new { useMapping = true }

local const lockfileResource =
  let (pwd = read("env:PWD"))
    // allow running from either `.github` dir or repo root
    read?("file://\(pwd)/\(lockfileName)")
      ?? read?("file://\(pwd)/.github/\(lockfileName)")

local allStepsWithVersionedUses =
  workflows
    .flatMap((it) -> it.jobs.toMap().values)
    .flatMap((it) -> it.steps.toList())
    .filter((it) -> it.uses != null && !it.uses.startsWith("./") && it.uses.contains("@v"))
    .distinctBy((it) -> it.uses)

local newLocks: Map<String, LockEntry> =
  allStepsWithVersionedUses
    .filter((it) -> currentLocks?.containsKey(it.uses) == false)
    .map((it) -> new ActionMeta { uses = it.uses!! }.lock)
    .toMap((it) -> it.usesWithTag, (it) -> it)

local class ActionMeta {
  local self = this

  uses: String

  local parts = uses.split("@")

  fixed base = parts[0]

  fixed version = parts[1]

  local orgRepoSubpath = base.split("/")

  fixed org = orgRepoSubpath[0]

  fixed repo = orgRepoSubpath[1]

  fixed sha = getSha(org, repo, version)

  fixed lock: LockEntry = new {
    base = self.base
    version = self.version
    sha = self.sha
  }

  local function getSha(org: String, repo: String, tag: String): String =
    let (
      gitOutput = read("https://github.com/\(org)/\(repo).git/info/refs?service=git-upload-pack")
    )
      gitOutput.text
        .split("\n")
        .find((it) -> it.endsWith("refs/tags/\(tag)"))
        .split(" ")
        .first
        .drop(4)
}

local derivedLocks: Locks =
  if (currentLocks == null)
    newLocks
  else
    currentLocks + newLocks

fixed result: Workflow = new {
  name = "__lockfile__"
  on {
    schedule {
      // never run (crontab means: run on February 31st)
      // language=cronexp
      new { cron = "* * 31 2 *" }
    }
  }
  jobs {
    ["locks"] {
      `runs-on` = "nothing"
    }
  }
  output {
    text =
      """
      #file: noinspection MandatoryParamsAbsent,UndefinedAction
      # This is a fake workflow that never runs.
      # It's used to pin actions to specific git SHAs when generating actual workflows.
      # It also gets updated by dependabot (see .github/dependabot.yml).
      \(super.text)
      """
    renderer {
      converters {
        ["jobs[locks].steps"] = (_) -> new Listing {
          local yamlRenderer = new YamlRenderer {}
          for (entry in derivedLocks.values.sortBy((it) -> it.usesWithTag)) {
            new {
              name = entry.usesWithTag
              uses = new RenderDirective {
                text =
                  " " + yamlRenderer.renderValue(entry.usesWithChecksum) + " # \(entry.version)"
              }
            }
          }
        }
      }
    }
  }
}

typealias Locks = Map<String, LockEntry>

class LockEntry {
  /// The base path of a `uses` block (e.g. `actions/checkout`)
  base: String

  /// The named version (e.g. `v6`)
  version: String(startsWith("v"))

  /// The git sha
  sha: String

  fixed usesWithTag = "\(base)@\(version)"

  fixed usesWithChecksum = "\(base)@\(sha)"
}
