//===----------------------------------------------------------------------===//
// Copyright Â© 2025 Apple Inc. and the Pkl project authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
/// A template for writing multiple workflows, whose actions are pinned to specific SHAs.
///
/// Typically, this module is placed in `.github/index.pkl`.
/// To produce output, the `-m` (or `--multiple-file-output-path`) flag must pointed at the repo's
/// `.github` directory.
///
/// ## Initialization
///
/// When first using this module, or whenever a new action is added, the lockfile and dependabot.yml
/// must be generated.
/// To generate these two files, pass `--prop mode=lockfile` during evaluation.
// TODO move me to pkl-pantry
open module pkl.impl.ghactions.VersionLockedCI

import "pkl:yaml"

import "@com.github.actions/AbstractTypedStep.pkl"
import "@com.github.actions/catalog.pkl"
import "@com.github.actions/Workflow.pkl"
import "@deepToTyped/deepToTyped.pkl"

import "DependabotV2.pkl"
import "LockfileGenerator.pkl"
import "steps/SetupPkl.pkl"

/// The effective workflows produced by this job, keyed by the workflow filename.
///
/// Example:
///
/// ```
/// workflows {
///   ["workflow/prb.yml"] = myPrbWorkflow
/// }
/// ```
workflows: Mapping<String, Workflow>

/// Dependabot configuration.
///
/// The github-actions ecosystem will be automatically added to this.
dependabot: DependabotV2

local lockfileName = "workflows/__lockfile__.yml"

local yamlParser: yaml.Parser = new { useMapping = true }

/// A map of action name to its checksum.
///
/// Parsed from `__lockfile__.yml`.
///
/// e.g. `Map("actions/checkout@v5", "actions/checkout@abc123")`
local locks: Map<String, String> =
  let (
    lockfileResource: Resource =
      let (pwd = read("env:PWD"))
      let (
        // allow running from either `.github` dir or repo root
        resource =
          read?("file://\(pwd)/\(lockfileName)")
            ?? read?("file://\(pwd)/.github/\(lockfileName)")
      )
        if (resource == null)
          throw("Missing lockfile! Run with `-p mode=lockfile` to generate it.")
        else
          resource
  )
  let (mapping = yamlParser.parse(lockfileResource) as Mapping)
  let (workflow = deepToTyped.apply(Workflow.getClass(), mapping) as Workflow)
  let (locksJob = workflow.jobs.toMap().values.first)
    locksJob.steps.toList().toMap((step) -> step.name!!, (step) -> step.uses!!)

/// Two modes:
/// * `test`: don't replace versions with SHAs (internal development option)
/// * `lockfile`: instead of generating normal workflow files, generate `workflows/__lockfile__.yml`
///    and `dependabot.yml`.
local mode = read?("prop:mode") as ("test" | "lockfile")?

local generator: LockfileGenerator = new {
  workflows = module.workflows.toMap().values
}

local effectiveDependabot: DependabotV2 = (dependabot) {
  updates {
    new {
      `package-ecosystem` = "github-actions"
      directory = "/"
      schedule {
        interval = "weekly"
      }
      `exclude-paths` {
        for (name, _ in workflows) {
          ".github/\(name)"
        }
      }
    }
  }
}

local function applyMappedStep(step: Workflow.Step, mapped: String) =
  if (step is AbstractTypedStep)
    (step) { sha = mapped.split("@").last }
  else
    (step) { uses = mapped }

// When dependabot submits a PR, add a commit that generates the rest of the workflows.
local dependabotPrPolish: Workflow = new {
  name = "dependabot-pr-polish"
  on {
    pull_request {}
  }
  jobs {
    ["update-pkl"] {
      `if` = "github.actor == 'dependabot[bot]'"
      `runs-on` = "ubuntu-latest"
      steps {
        (catalog.`actions/checkout@v6`) {
          with {
            `persist-credentials` = true
          }
        }
        new {
          name = "Check diff"
          id = "check-lockfile"
          // language=bash
          run =
            """
            if git diff HEAD~1 | grep -q .github/workflows/__lockfile__.yml; then
              echo "lockfile-changed=true" >> $GITHUB_OUTPUT
            else
              echo "lockfile-changed=false" >> $GITHUB_OUTPUT
            fi
            """
        }
        (new SetupPkl { version = "0.30.1" }.step) {
          `if` = "steps.check-lockfile.outputs.lockfile-changed == 'true'"
        }
        new {
          name = "Update generated workflows"
          `if` = "steps.check-lockfile.outputs.lockfile-changed == 'true'"
          run = "pkl eval --project-dir .github/ -m .github/ .github/index.pkl"
        }
        new {
          name = "Commit and push"
          `if` = "steps.check-lockfile.outputs.lockfile-changed == 'true'"
          // language=bash
          run =
            """
            git add .
            git commit -m "Update generated Pkl-based workflows"
            git push
            """
        }
      }
    }
  }
}

local effectiveWorkflows = (workflows) {
  ["workflows/__dependabot_pr_polish__.yml"] = dependabotPrPolish
}

local mappedWorkflows: Mapping<String, Workflow> =
  if (mode == "test")
    effectiveWorkflows
  else
    new {
      for (name, workflow in effectiveWorkflows) {
        [name] = (workflow) {
          jobs {
            [[true]] {
              steps = new {
                for (step in super.steps) {
                  step |> replaceVersionWithSha
                }
              }
            }
          }
        }
      }
    }

local replaceVersionWithSha = (it) ->
  if (it.uses == null)
    it
  else
    let (mapped = locks.getOrNull(it.uses))
      if (mapped == null)
        throw("The lockfile is out-dated and must be re-generated (using `-p mode=lockfile`)")
      else
        applyMappedStep(it, mapped)

output {
  text = "This module only supports multiple-file output. Evaluate me with the `-m` flag."
  files =
    if (mode == "lockfile")
      new {
        [lockfileName] = generator.result.output
        ["dependabot.yml"] = effectiveDependabot.output
      }
    else
      new {
        for (name, workflow in mappedWorkflows) {
          [name] = workflow.output
        }
      }
}
